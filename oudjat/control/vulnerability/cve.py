"""A module to describe security vulnerabilities."""

import re
from datetime import datetime
from typing import Dict, List, Union

from oudjat.connectors.vuln import CVEConnector, CVEDatabase
from oudjat.utils.time_utils import DateFlag, DateFormat, TimeConverter

from .definitions import CVE_REGEX
from .severity import Severity


class CVSS:
    """A class to describe CVSS metric."""

    # ****************************************************************
    # Attributes & Constructors

    def __init__(
        self,
        score: float = 0,
        version: float = 4.0,
    ) -> None:
        """
        Create a new instance of CVE.

        Args:
            score (float)  : CVSS score (0-10)
            version (float): the CVSS metric version
        """

        self.score = score
        self.version = version
        self.severity = self.resolve_severity()

    # ****************************************************************
    # Methods

    def get_score(self) -> float:
        """
        Return the CVSS score.

        Returns:
            float : CVE CVSS score
        """

        return self.score

    def get_version(self) -> float:
        """
        Return the CVSS version.

        Returns:
            float: the CVSS version (3.0, 4.0, etc.)
        """

        return self.version

    def get_severity(self) -> Severity:
        """
        Return the severity.

        Returns:
            Severity: the severity associated with the current CVSS
        """

        return self.severity

    def set_score(self, score: float) -> None:
        """
        Set the vulnerability CVSS score.

        Args:
            score (float) : new CVSS score
        """

        if CVSS.check_score(score):
            self.score = score
            self.resolve_severity()

        else:
            raise ValueError(
                f"{__class__.__name__}.set_score::{score} is not a valid CVSS score. You must provide a value between 0 and 10"
            )

    def resolve_severity(self) -> None:
        """Resolve the severity based on the CVSS score."""

        self.severity = Severity.from_cvss(self.score)

    def __str__(self) -> str:
        """
        Return the current CVSS as a string.

        Returns:
            str: a string representation of the current CVSS
        """

        return f"{self.score} ({self.severity})"

    def __float__(self) -> float:
        """
        Return the current CVSS as a float.

        Returns:
            float: the score of the current CVSS
        """

        return self.score

    def to_dict(self) -> Dict:
        """
        Convert the current CVSS into a dictionary.

        Returns:
            Dict: dictionary representation of the current CVSS
        """

        return {"score": self.score, "severity": self.severity, "version": self.version}

    # ****************************************************************
    # Static methods

    @staticmethod
    def check_score(score: float) -> bool:
        """
        Check whether the given cvss score is valid.

        Args:
            score (float) : CVSS score

        Return:
            bool : wheither or not the CVSS score is valid (between 0 and 10)
        """

        return 0 <= score <= 10


class CVE:
    """A class to handle vulnerabilities."""

    # ****************************************************************
    # Attributes & Constructors

    def __init__(
        self,
        ref: str,
        cvss: float = 0,
        description: str = None,
    ) -> None:
        """
        Create a new instance of CVE.

        Args:
            ref (str)                     : CVE ref (CVE-YYYY-XXXXX)
            cvss (float)                  : CVSS score of the CVE
            description (str)             : CVE description
        """

        if not self.check_ref(ref):
            raise ValueError(f"{__class__.__name__}::{ref} is not a valid CVE id")

        # TODO: maybe check if the CVE actually exists

        self.ref: str = ref
        self.cvss: CVSS = CVSS(score=cvss)
        self.status: str = None

        self.vectors: Dict[str, str] = {"vectorString": None, "attackVector": None}
        self.requirements: Dict[str, str] = {"privilegesRequired": None, "attackRequirements": None}

        self.dates: Dict[str, datetime] = {
            "published": None,
            "updated": None,
        }

        self.description: str = description
        self.source: List[str] = []
        self.link: Dict[str, str] = {
            db.name: db.connector.get_cve_url(cve=self.ref) for db in CVEDatabase
        }

    # ****************************************************************
    # Getters and Setters

    def get_ref(self) -> str:
        """
        Return the CVE reference.

        Returns:
            str : CVE ref
        """

        return self.ref

    def get_cvss(self) -> CVSS:
        """
        Return the CVSS score.

        Returns:
            CVSS: CVSS instance
        """

        return self.cvss

    def get_cvss_score(self) -> float:
        """
        Return the CVSS score of the current CVE.

        Returns:
            float: CVSS score
        """

        return self.cvss.get_score()

    def get_severity(self) -> str:
        """
        Return the severity of the current CVE based on its CVSS.

        Returns:
            str : CVE severity
        """

        return self.cvss.get_severity()

    def get_link(self) -> str:
        """
        Return CVE link.

        Returns:
            str : CVE link
        """

        return self.link

    def convert_cve_dates(self, date_to_convert: Union[str, datetime]) -> datetime:
        """
        Convert the provided date if it is representedd by a string.

        Args:
            date_to_convert (str | datetime): date to convert

        Returns:
            datetime: date time object if the input date is a string. Unchanged input date otherwise
        """

        return (
            TimeConverter.str_to_date(date_to_convert, DateFormat.from_flag(DateFlag.YMD_HMS))
            if isinstance(date_to_convert, str)
            else date_to_convert
        )

    def set_publish_date(self, new_date: Union[str, datetime]) -> None:
        """
        Set the plublish date value.

        Args:
            new_date (str | datetime): new publish date value
        """

        self.dates["published"] = self.convert_cve_dates(new_date)

    def set_change_date(self, new_date: Union[str, datetime]) -> None:
        """
        Set the change date value.

        Args:
            new_date (str | datetime): new change date value
        """

        self.dates["updated"] = self.convert_cve_dates(new_date)

    def copy(self, cve: "CVE") -> None:
        """
        Copy the given cve informations.

        Args:
            cve (CVE) : cve to copy
        """

        self.set_from_dict(cve.to_dict(minimal=False))
        print(self)

    # ****************************************************************
    # Resolvers & Parsers

    def connector_parse(self, cve_db: CVEDatabase = None, **kwargs) -> None:
        """
        Parse CVE data from a CVEConnector.

        Args:
            cve_db (CVEDatabase): If not none, the provided cve database will be used to replace the current connector
            **kwargs            : Additional arguments passed to the connector.search method
        """

        if cve_db is None:
            cve_db = CVEDatabase.CVEORG

        cve_connector: CVEConnector = cve_db.connector()

        cve_data = cve_connector.search(search_filter=self.ref, **kwargs)[0]
        self.get_cvss().set_score(cve_data["metrics"]["score"])

        self.set_publish_date(CVEConnector.format_date_str(cve_data["dates"]["published"]))
        self.set_change_date(CVEConnector.format_date_str(cve_data["dates"]["updated"]))

        self.description = cve_data["description"]
        self.status = cve_data["status"]
        self.source.extend(cve_data["source"])

        self.vectors = cve_data["vectors"]
        self.requirements = cve_data["requirements"]

    # ****************************************************************
    # Converters

    def __str__(self, show_severity: bool = False) -> str:
        """
        Convert the current instance to a string.

        Args:
            show_severity (bool) : wheither to show the CVE severity

        Return:
            str : CVE string
        """

        base = f"{self.ref} ({self.cvss})"

        if show_severity:
            base += f"({self.severity.name})"

        return base

    def to_dict(self) -> Dict:
        """
        Convert the current instance to a dictionary.

        Return:
            Dict: CVE converted to a dictionary
        """

        cvss_dict = self.cvss.to_dict()
        dates_dict = {
            k: TimeConverter.date_to_str(v, DateFormat.from_flag(DateFlag.YMD_HMS))
            for k, v in self.dates.items()
        }

        return {
            "ref": self.ref,
            **dates_dict,
            "cvss_score": cvss_dict["score"],
            "cvss_version": cvss_dict["version"],
            "cvss_severity": cvss_dict["severity"].name,
            "status": self.status,
            "description": self.description,
            **self.vectors,
            **self.requirements,
            "link": list(self.link.values()),
            "source": self.source,
        }

    # ****************************************************************
    # Static methods

    @staticmethod
    def check_ref(cve_ref: str) -> bool:
        """
        Check whether the given cve id is valid.

        Args:
            cve_ref (str) : CVE ref

        Return:
            bool : wheither the CVE ref is valid or not
        """

        return re.match(CVE_REGEX, cve_ref)

    @staticmethod
    def create_from_dict(cve_dict: Dict) -> "CVE":
        """
        Create a CVE instance from a dictionary.

        Args:
            cve_dict (Dict) : CVE dictionary

        Return:
            CVE : cve instance
        """

        return CVE(
            ref=cve_dict.get("ref"),
            cvss=cve_dict.get("cvss"),
            date=cve_dict.get("publish_date", ""),
            description=cve_dict.get("description", ""),
        )

    @staticmethod
    def find_cve_by_ref(ref: str, cve_list: List["CVE"]) -> "CVE":
        """
        Find a CVE instance by ref in a list of CVEs.

        Args:
            ref (str)            : CVE ref
            cve_list (List[CVE]) : list of CVE to search in

        Return:
            CVE : cve instance based on provided ref
        """

        if not CVE.check_ref(ref):
            raise ValueError(
                f"{__class__.__name__}.find_cve_by_ref::Invalid CVE reference provided: {ref}"
            )

        return next(filter(CVE.cve_ref_is, cve_list, [ref] * len(cve_list)))

    @staticmethod
    def cve_ref_is(cve: "CVE", value: str) -> bool:
        """
        Check if the provided CVE ref is equal to the given value.
        """

        return cve.get_ref() == value

    # TODO: implement SQLi database
    @staticmethod
    def resolve_cve_data(cves: List["CVE"], cve_data: List["CVE"] = None) -> None:
        """
        Resolve CVE data for all related CVE.

        Args:
            cves (List[CVE])     : list of CVE instances to resolve information from Nist API
            cve_data (List[CVE]) : a list of CVE instances to use as information base
        """

        print(f"\nResolving {len(cves)} CVEs data...")

        for cve in cves:
            # Checks if the current CVE can be found in the provided cve list. If not : parse Nist page
            cve_imported = False
            if cve_data is not None:
                cve_search = CVE.find_cve_by_ref(ref=cve.get_ref(), cve_list=cve_data)

                if cve_search:
                    print(f"Found {cve.get_ref()} in CVE list ! Copying data...")
                    cve.copy(cve_search)
                    cve_imported = True

            if not cve_imported:
                cve.parse_nist(verbose=False)

    @staticmethod
    def max_cve(cves: List["CVE"]) -> List["CVE"]:
        """
        Return the highest(s) cve(s).

        Args:
            cves (List[CVE]) : list of CVE to check

        Return:
            List[CVE] : sub list of the provided argument list with the highest CVSS score
        """

        if len(cves) == 0 or cves is None:
            print("No comparison possible: no CVE related")
            return None

        print(f"\nResolving most critical CVEs among {len(cves)} provided")

        max_cve = max(cves, key=lambda cve: cve.get_cvss())

        if max_cve is not None:
            max_cve = [cve for cve in cves if cve.get_cvss() == max_cve.get_cvss()]

        print("\nMax CVEs are:")
        for cve in max_cve:
            print(cve)

        return max_cve
