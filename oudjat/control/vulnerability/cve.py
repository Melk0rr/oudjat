"""A module to describe security vulnerabilities."""

import logging
import re
from datetime import datetime
from typing import Any, override

from oudjat.connectors.vuln import CVEConnector, CVEDatabase
from oudjat.connectors.vuln.cve_formats import (
    CVEDataFormat,
    CVEDatesFmt,
    CVERequirementsFmt,
    CVEVectorsFmt,
)
from oudjat.utils import Context
from oudjat.utils.time_utils import DateFlag, DateFormat, TimeConverter

from .cvss import CVSS
from .definitions import CVE_REGEX
from .exceptions import InvalidCVERefError
from .severity import Severity


class CVE:
    """A class to handle vulnerabilities."""

    # ****************************************************************
    # Attributes & Constructors

    def __init__(
        self,
        ref: str,
        cvss: float = 0,
        description: str | None = None,
    ) -> None:
        """
        Create a new instance of CVE.

        Args:
            ref (str)        : CVE ref (CVE-YYYY-XXXXX)
            cvss (float)     : CVSS score of the CVE
            description (str): CVE description
        """

        self.logger: "logging.Logger" = logging.getLogger(__name__)
        if not self.check_ref(ref):
            raise InvalidCVERefError(f"{Context()}::{ref} is not a valid CVE id")

        # TODO: maybe check if the CVE actually exists

        self._ref: str = ref
        self._cvss: "CVSS" = CVSS(score=cvss)
        self._status: str | None = None

        self._dates: "CVEDatesFmt" = {"published": "", "updated": ""}
        self._requirements: "CVERequirementsFmt" = {
            "attackRequirements": "",
            "privilegesRequired": "",
        }
        self._vectors: "CVEVectorsFmt" = {"attackVector": "", "vectorStr": ""}

        self._description: str | None = description
        self._source: list[str] = []

    # ****************************************************************
    # Getters and Setters

    @property
    def ref(self) -> str:
        """
        Return the CVE reference.

        Returns:
            str : CVE ref
        """

        return self._ref

    @property
    def cvss(self) -> "CVSS":
        """
        Return the CVSS score.

        Returns:
            CVSS: CVSS instance
        """

        return self._cvss

    @property
    def cvss_score(self) -> float:
        """
        Return the CVSS score of the current CVE.

        Returns:
            float: CVSS score
        """

        return self._cvss.score

    @property
    def severity(self) -> "Severity":
        """
        Return the severity of the current CVE based on its CVSS.

        Returns:
            str : CVE severity
        """

        return self._cvss.severity

    @property
    def status(self) -> str | None:
        """
        Return the CVE status.

        Returns:
            str | None: CVE status string if any. Else None
        """

        return self._status

    @property
    def vectors(self) -> "CVEVectorsFmt":
        """
        Return the CVE vectors informations.

        Returns:
            CVEVectorsFmt: vector string and attack vector infos
        """

        return self._vectors

    @property
    def requirements(self) -> "CVERequirementsFmt":
        """
        Return the CVE exploit requirements.

        Returns:
            CVERequirementsFmt: priviledge requirements and attack requirements
        """

        return self._requirements

    @property
    def dates(self) -> "CVEDatesFmt":
        """
        Return the CVE exploit requirements.

        Returns:
            CVEDatesFmt: publish and updated dates
        """

        return self._dates

    @dates.setter
    def dates(self, new_date: "CVEDatesFmt") -> None:
        """
        Set the plublish date value.

        Args:
            new_date (str | datetime): new publish date value
        """

        self._dates["published"] = self._convert_cve_dates(new_date["published"])
        self._dates["updated"] = self._convert_cve_dates(new_date["updated"])

    @property
    def description(self) -> str | None:
        """
        Return the CVE description.

        Returns:
            str | None: CVE description string if set. Else, None
        """

        return self._description

    @property
    def link(self) -> dict[str, str]:
        """
        Return CVE link.

        Returns:
            str : CVE link
        """

        return {db.name: db.connector.cve_url(cve=self._ref) for db in CVEDatabase}

    def _convert_cve_dates(self, date_to_convert: str | datetime) -> datetime:
        """
        Convert the provided date if it is representedd by a string.

        Args:
            date_to_convert (str | datetime): date to convert

        Returns:
            datetime: date time object if the input date is a string. Unchanged input date otherwise
        """

        return (
            TimeConverter.str_to_date(date_to_convert, DateFormat.from_flag(DateFlag.YMD_HMS))
            if isinstance(date_to_convert, str)
            else date_to_convert
        )

    def copy(self, cve: "CVE") -> None:
        """
        Copy the given cve informations.

        Args:
            cve (CVE) : CVE to copy
        """

        self._cvss = cve.cvss
        self._status = cve.status
        self._dates = cve.dates
        self._vectors = cve.vectors
        self._requirements = cve.requirements
        self._description = cve.description

        self.logger.debug(f"{Context()}::{self.to_dict()}")

    # ****************************************************************
    # Resolvers & Parsers

    def connector_parse(self, cve_db: "CVEDatabase | None" = None, **kwargs: Any) -> None:
        """
        Parse CVE data from a CVEConnector.

        Args:
            cve_db (CVEDatabase): If not none, the provided cve database will be used to replace the current connector
            **kwargs            : Additional arguments passed to the connector.search method
        """

        if cve_db is None:
            cve_db = CVEDatabase.CVEORG

        cve_connector: "CVEConnector" = cve_db.connector()

        cve_data = cve_connector.fetch(self.ref, **kwargs)
        if len(cve_data) > 0:
            cve_data = cve_data[0]

            self.cvss.score = cve_data["metrics"]["score"]

            self.dates = cve_data["dates"]

            self._description = cve_data["description"]
            self._status = cve_data["status"]
            self._source.extend(cve_data["sources"])

            self._vectors = cve_data["vectors"]
            self._requirements = cve_data["requirements"]

        else:
            self.logger.error(
                f"{Context()}::Could not fetch {self.ref} data from {cve_db.connector.API_URL}\nCheck if you have reached the API maximum request rate"
            )

    # ****************************************************************
    # Operator overloading

    def __gt__(self, other: "CVE") -> bool:
        """
        Check whether the current CVE cvss score is greater than the other provided CVE cvss score.

        Args:
            other (CVE): The other CVE to compare to the current one

        Returns:
            bool: True if the current CVE cvss score is greater than the other one
        """

        return self.cvss_score > other.cvss_score

    def __ge__(self, other: "CVE") -> bool:
        """
        Check whether the current CVE cvss score is greater or equal to the other provided CVE cvss score.

        Args:
            other (CVE): The other CVE to compare to the current one

        Returns:
            bool: True if the current CVE cvss score is greater or equal to the other one
        """

        return self.cvss_score >= other.cvss_score

    def __lt__(self, other: "CVE") -> bool:
        """
        Check whether the current CVE cvss score is lower than the other provided CVE cvss score.

        Args:
            other (CVE): The other CVE to compare to the current one

        Returns:
            bool: True if the current CVE cvss score is lower than the other one
        """

        return self.cvss_score < other.cvss_score

    def __le__(self, other: "CVE") -> bool:
        """
        Check whether the current CVE cvss score is lower or equal to the other provided CVE cvss score.

        Args:
            other (CVE): The other CVE to compare to the current one

        Returns:
            bool: True if the current CVE cvss score is lower or equal to the other one
        """

        return self.cvss_score <= other.cvss_score

    # ****************************************************************
    # Converters

    @override
    def __str__(self) -> str:
        """
        Convert the current instance to a string.

        Args:
            show_severity (bool) : whether to show the CVE severity

        Return:
            str : CVE string
        """

        return f"{self.ref} ({self.cvss})"

    def to_dict(self) -> dict[str, Any]:
        """
        Convert the current instance to a dictionary.

        Return:
            dict[str, Any]: A dictionary representation of the CVE
        """

        return {
            "ref": self.ref,
            "dates": self._dates,
            "cvss": self.cvss.to_dict(),
            "status": self._status,
            "description": self._description,
            "vectors": self._vectors,
            "requirements": self._requirements,
            "link": self.link,
            "source": self._source,
        }

    # ****************************************************************
    # Class methods

    @classmethod
    def create_from_dict(cls, cve_dict: "CVEDataFormat") -> "CVE":
        """
        Create a CVE instance from a dictionary.

        Args:
            cve_dict (CVEDataFormat): CVE dictionary format

        Return:
            CVE: cve instance
        """

        return cls(
            ref=cve_dict.get("id"),
            cvss=cve_dict.get("metrics").get("score"),
            description=cve_dict.get("description", ""),
        )

    # ****************************************************************
    # Static methods

    @staticmethod
    def check_ref(cve_ref: str) -> bool:
        """
        Check whether the given cve id is valid.

        Args:
            cve_ref (str) : CVE ref

        Return:
            bool : wheither the CVE ref is valid or not
        """

        return re.match(CVE_REGEX, cve_ref) is not None

    @staticmethod
    def find_cve_by_ref(ref: str, cve_list: list["CVE"]) -> "CVE":
        """
        Find a CVE instance by ref in a list of CVEs.

        Args:
            ref (str)           : CVE ref
            cve_list (list[CVE]): list of CVE to search in

        Return:
            CVE : cve instance based on provided ref
        """

        if not CVE.check_ref(ref):
            raise InvalidCVERefError(f"{Context()}::Invalid CVE reference provided: {ref}")

        def cve_ref_is(cve: "CVE") -> bool:
            return cve.ref == ref

        return next(filter(cve_ref_is, cve_list))

    # TODO: implement SQLi database
    @staticmethod
    def resolve(cves: list["CVE"], cve_data: list["CVE"] | None = None) -> None:
        """
        Resolve CVE data for all related CVE.

        Args:
            cves (list[CVE])     : list of CVE instances to resolve information from Nist API
            cve_data (list[CVE]) : a list of CVE instances to use as information base
        """

        context = Context()
        logger = logging.getLogger(__name__)
        logger.info(f"{context}::Resolving {len(cves)} CVEs data")

        for cve in cves:
            # Checks if the current CVE can be found in the provided cve list. If not : parse connector page
            cve_imported = False
            if cve_data is not None:
                cve_search = CVE.find_cve_by_ref(ref=cve.ref, cve_list=cve_data)

                if cve_search:
                    logger.info(f"{context}::Found {cve.ref} in CVE list ! Copying data")
                    cve.copy(cve_search)
                    cve_imported = True

            if not cve_imported:
                cve.connector_parse(verbose=False)

    @staticmethod
    def max_cve(cves: list["CVE"]) -> list["CVE"]:
        """
        Return the highest(s) cve(s).

        Args:
            cves (list[CVE]) : list of CVE to check

        Return:
            list[CVE] : sub list of the provided argument list with the highest CVSS score
        """

        context = Context()
        logger = logging.getLogger(__name__)
        logger.info(f"\nResolving most critical CVEs among {len(cves)} provided")

        if len(cves) == 0:
            logger.warning(f"{context}::No comparison possible: CVE list is empty")
            return []

        max_cve = max(cves, key=lambda cve: cve.cvss_score)

        def score_match_max(cve: "CVE") -> bool:
            return cve.cvss_score == max_cve.cvss_score

        max_cve_list: list["CVE"] = list(filter(score_match_max, cves))

        logger.debug(f"{context}::Max CVEs ({max_cve_list[0].cvss_score}) are:")
        for cve in max_cve_list:
            logger.debug(f"{context}::{cve}")

        return max_cve_list
