"""A module to describe security vulnerabilities."""

import re
from datetime import datetime
from typing import Any, override

from oudjat.connectors.vuln import CVEConnector, CVEDatabase
from oudjat.connectors.vuln.cve_formats import (
    CVEDataFormat,
    CVEDatesFmt,
    CVERequirementsFmt,
    CVEVectorsFmt,
)
from oudjat.utils.time_utils import DateFlag, DateFormat, TimeConverter

from .cvss import CVSS
from .definitions import CVE_REGEX
from .severity import Severity


class CVE:
    """A class to handle vulnerabilities."""

    # ****************************************************************
    # Attributes & Constructors

    def __init__(
        self,
        ref: str,
        cvss: float = 0,
        description: str | None = None,
    ) -> None:
        """
        Create a new instance of CVE.

        Args:
            ref (str)        : CVE ref (CVE-YYYY-XXXXX)
            cvss (float)     : CVSS score of the CVE
            description (str): CVE description
        """

        if not self.check_ref(ref):
            raise ValueError(f"{__class__.__name__}::{ref} is not a valid CVE id")

        # TODO: maybe check if the CVE actually exists

        self._ref: str = ref
        self._cvss: "CVSS" = CVSS(score=cvss)
        self._status: str | None = None

        self._dates: "CVEDatesFmt"
        self._requirements: "CVERequirementsFmt"
        self._vectors: "CVEVectorsFmt"

        self._description: str | None = description
        self._source: list[str] = []

    # ****************************************************************
    # Getters and Setters

    @property
    def ref(self) -> str:
        """
        Return the CVE reference.

        Returns:
            str : CVE ref
        """

        return self._ref

    @property
    def cvss(self) -> "CVSS":
        """
        Return the CVSS score.

        Returns:
            CVSS: CVSS instance
        """

        return self._cvss

    @property
    def cvss_score(self) -> float:
        """
        Return the CVSS score of the current CVE.

        Returns:
            float: CVSS score
        """

        return self._cvss.score

    @property
    def severity(self) -> "Severity":
        """
        Return the severity of the current CVE based on its CVSS.

        Returns:
            str : CVE severity
        """

        return self._cvss.severity


    @property
    def status(self) -> str | None:
        """
        Return the CVE status.

        Returns:
            str | None: CVE status string if any. Else None
        """

        return self._status

    @property
    def vectors(self) -> "CVEVectorsFmt":
        """
        Return the CVE vectors informations.

        Returns:
            CVEVectorsFmt: vector string and attack vector infos
        """

        return self._vectors

    @property
    def requirements(self) -> "CVERequirementsFmt":
        """
        Return the CVE exploit requirements.

        Returns:
            CVERequirementsFmt: priviledge requirements and attack requirements
        """

        return self._requirements

    @property
    def dates(self) -> "CVEDatesFmt":
        """
        Return the CVE exploit requirements.

        Returns:
            CVEDatesFmt: publish and updated dates
        """

        return self._dates

    @property
    def description(self) -> str | None:
        """
        Return the CVE description.

        Returns:
            str | None: CVE description string if set. Else, None
        """

        return self._description

    @property
    def link(self) -> dict[str, str]:
        """
        Return CVE link.

        Returns:
            str : CVE link
        """

        return {
            db.name: db.connector.cve_url(cve=self._ref) for db in CVEDatabase
        }

    def _convert_cve_dates(self, date_to_convert: str | datetime) -> datetime:
        """
        Convert the provided date if it is representedd by a string.

        Args:
            date_to_convert (str | datetime): date to convert

        Returns:
            datetime: date time object if the input date is a string. Unchanged input date otherwise
        """

        return (
            TimeConverter.str_to_date(date_to_convert, DateFormat.from_flag(DateFlag.YMD_HMS))
            if isinstance(date_to_convert, str)
            else date_to_convert
        )

    def set_publish_date(self, new_date: str | datetime) -> None:
        """
        Set the plublish date value.

        Args:
            new_date (str | datetime): new publish date value
        """

        self._dates["published"] = self._convert_cve_dates(new_date)

    def set_change_date(self, new_date: str | datetime) -> None:
        """
        Set the change date value.

        Args:
            new_date (str | datetime): new change date value
        """

        self._dates["updated"] = self._convert_cve_dates(new_date)

    def copy(self, cve: "CVE") -> None:
        """
        Copy the given cve informations.

        Args:
            cve (CVE) : cve to copy
        """

        self._cvss = cve.cvss
        self._status = cve.status
        self._dates = cve.dates
        self._vectors = cve.vectors
        self._requirements = cve.requirements
        self._description = cve.description

        print(self)

    # ****************************************************************
    # Resolvers & Parsers

    def connector_parse(self, cve_db: "CVEDatabase | None" = None, **kwargs: Any) -> None:
        """
        Parse CVE data from a CVEConnector.

        Args:
            cve_db (CVEDatabase): If not none, the provided cve database will be used to replace the current connector
            **kwargs            : Additional arguments passed to the connector.search method
        """

        if cve_db is None:
            cve_db = CVEDatabase.CVEORG

        cve_connector: CVEConnector = cve_db.connector()

        cve_data = cve_connector.fetch(self.ref, **kwargs)[0]
        self.cvss.score = cve_data["metrics"]["score"]

        self.set_publish_date(CVEConnector.format_date_str(cve_data["dates"]["published"]))
        self.set_change_date(CVEConnector.format_date_str(cve_data["dates"]["updated"]))

        self._description = cve_data["description"]
        self._status = cve_data["status"]
        self._source.extend(cve_data["source"])

        self._vectors = cve_data["vectors"]
        self._requirements = cve_data["requirements"]

    # ****************************************************************
    # Converters

    @override
    def __str__(self) -> str:
        """
        Convert the current instance to a string.

        Args:
            show_severity (bool) : whether to show the CVE severity

        Return:
            str : CVE string
        """

        return f"{self.ref} ({self.cvss})"

    def to_dict(self) -> dict[str, Any]:
        """
        Convert the current instance to a dictionary.

        Return:
            Dict: CVE converted to a dictionary
        """

        cvss_dict = self.cvss.to_dict()

        return {
            "ref": self.ref,
            **self._dates,
            "cvss_score": cvss_dict["score"],
            "cvss_version": cvss_dict["version"],
            "cvss_severity": cvss_dict["severity"].name,
            "status": self._status,
            "description": self._description,
            **self._vectors,
            **self._requirements,
            "link": list(self.link.values()),
            "source": self._source,
        }

    # ****************************************************************
    # Static methods

    @staticmethod
    def check_ref(cve_ref: str) -> bool:
        """
        Check whether the given cve id is valid.

        Args:
            cve_ref (str) : CVE ref

        Return:
            bool : wheither the CVE ref is valid or not
        """

        return re.match(CVE_REGEX, cve_ref) is not None

    @staticmethod
    def create_from_dict(cve_dict: "CVEDataFormat") -> "CVE":
        """
        Create a CVE instance from a dictionary.

        Args:
            cve_dict (Dict) : CVE dictionary

        Return:
            CVE : cve instance
        """

        return CVE(
            ref=cve_dict.get("id"),
            cvss=cve_dict.get("metrics").get("score"),
            description=cve_dict.get("description", ""),
        )

    @staticmethod
    def find_cve_by_ref(ref: str, cve_list: list["CVE"]) -> "CVE":
        """
        Find a CVE instance by ref in a list of CVEs.

        Args:
            ref (str)            : CVE ref
            cve_list (List[CVE]) : list of CVE to search in

        Return:
            CVE : cve instance based on provided ref
        """

        if not CVE.check_ref(ref):
            raise ValueError(
                f"{__class__.__name__}.find_cve_by_ref::Invalid CVE reference provided: {ref}"
            )

        def cve_ref_is(cve: "CVE") -> bool:
            return cve.ref == ref

        return next(filter(cve_ref_is, cve_list))

    # TODO: implement SQLi database
    @staticmethod
    def resolve_cve_data(cves: list["CVE"], cve_data: list["CVE"] | None = None) -> None:
        """
        Resolve CVE data for all related CVE.

        Args:
            cves (list[CVE])     : list of CVE instances to resolve information from Nist API
            cve_data (list[CVE]) : a list of CVE instances to use as information base
        """

        print(f"\nResolving {len(cves)} CVEs data...")

        for cve in cves:
            # Checks if the current CVE can be found in the provided cve list. If not : parse connector page
            cve_imported = False
            if cve_data is not None:
                cve_search = CVE.find_cve_by_ref(ref=cve.ref, cve_list=cve_data)

                if cve_search:
                    print(f"Found {cve.ref} in CVE list ! Copying data...")
                    cve.copy(cve_search)
                    cve_imported = True

            if not cve_imported:
                cve.connector_parse(verbose=False)

    @staticmethod
    def max_cve(cves: list["CVE"]) -> list["CVE"]:
        """
        Return the highest(s) cve(s).

        Args:
            cves (List[CVE]) : list of CVE to check

        Return:
            List[CVE] : sub list of the provided argument list with the highest CVSS score
        """

        if len(cves) == 0:
            print("No comparison possible: no CVE related")
            return []

        print(f"\nResolving most critical CVEs among {len(cves)} provided")

        max_cve = max(cves, key=lambda cve: cve.cvss_score)

        def score_match_max(cve: "CVE") -> bool:
            return cve.cvss_score == max_cve.cvss_score

        max_cve_list: list["CVE"] = list(filter(score_match_max, cves))

        print("\nMax CVEs are:")
        for cve in max_cve_list:
            print(cve)

        return max_cve_list
